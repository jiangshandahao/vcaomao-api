<!DOCTYPE html>
<!-- saved from url=(0052)component-specs.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <title>组件的详细说明和生命周期（Component Specs and Lifecycle） | React</title>
  <meta name="viewport" content="width=device-width">
  <meta property="og:title" content="组件的详细说明和生命周期（Component Specs and Lifecycle） | React">
  <meta property="og:type" content="website">
  <meta property="og:url" content="docs/component-specs.html">
  <meta property="og:image" content="img/logo_og.png">
  <meta property="og:description" content="用于构建用户界面的Javascript库">

  <link rel="shortcut icon" href="favicon.ico">

  <link rel="stylesheet" href="./component-specs_files/syntax.css">
  <link rel="stylesheet" href="./component-specs_files/codemirror.css">
  <link rel="stylesheet" href="./component-specs_files/react.css">

  <!--[if lte IE 8]>
  <script type="text/javascript" src="/react/js/html5shiv.min.js"></script>
  <script type="text/javascript" src="/react/js/es5-shim.min.js"></script>
  <script type="text/javascript" src="/react/js/es5-sham.min.js"></script>
  <![endif]-->
  <script src="./component-specs_files/hm.js"></script><script type="text/javascript" src="./component-specs_files/codemirror.js"></script>
  <script type="text/javascript" src="./component-specs_files/javascript.js"></script>
  <script type="text/javascript" src="./component-specs_files/react.js"></script>
  <script type="text/javascript" src="./component-specs_files/JSXTransformer.js"></script>
  <script type="text/javascript" src="./component-specs_files/live_editor.js"></script>
  <script type="text/javascript" src="./component-specs_files/showdown.js"></script>
  


</head>
<body>

  <div class="container">

    <div class="nav-main">
      <div class="wrap">
        <a class="nav-home" href="index.html">
          <img class="nav-logo" src="./component-specs_files/logo.svg" width="36" height="36">
          React
        </a>
        <ul class="nav-site">
          <li><a href="getting-started.html" class="active">文档</a></li>
          <li><a href="http://react-china.org/" target="_blank">中文社区</a>
          </li><li><a href="downloads.html">下载</a></li>
          <!-- <li><a href="/react/blog/">博客</a></li> -->
          <li><a href="https://github.com/reactjs-cn/react-docs">github</a>
          </li><li><a href="about.html">关于我们</a>
        </li></ul>
      </div>
    </div>

    

    <section class="content wrap documentationContent">
  <div class="nav-docs">
  <!-- Docs Nav -->
  
    <div class="nav-docs-section">
      <h3>快速入门</h3>
      <ul>
        
          <li>
            <a href="getting-started.html">快速开始</a>
            
          </li>
        
          <li>
            <a href="tutorial.html">教程</a>
            
          </li>
        
          <li>
            <a href="thinking-in-react.html">深入理解React</a>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>指南</h3>
      <ul>
        
          <li>
            <a href="why-react.html">为什么使用 React?</a>
            
          </li>
        
          <li>
            <a href="displaying-data.html">数据呈现</a>
            
              <ul>
                
                  <li>
                    <a href="jsx-in-depth.html">深入理解JSX</a>
                  </li>
                
                  <li>
                    <a href="jsx-spread.html">JSX的延展属性</a>
                  </li>
                
                  <li>
                    <a href="jsx-gotchas.html">JSX的陷阱</a>
                  </li>
                
              </ul>
            
          </li>
        
          <li>
            <a href="interactivity-and-dynamic-uis.html">富交互性的动态用户界面</a>
            
          </li>
        
          <li>
            <a href="multiple-components.html">复合组件</a>
            
          </li>
        
          <li>
            <a href="reusable-components.html">可复用组件</a>
            
          </li>
        
          <li>
            <a href="transferring-props.html">传递 Props</a>
            
          </li>
        
          <li>
            <a href="forms.html">表单组件</a>
            
          </li>
        
          <li>
            <a href="working-with-the-browser.html">浏览器中的工作原理</a>
            
              <ul>
                
                  <li>
                    <a href="more-about-refs.html">关于Refs的更多内容</a>
                  </li>
                
              </ul>
            
          </li>
        
          <li>
            <a href="tooling-integration.html">Tooling Integration</a>
            
          </li>
        
          <li>
            <a href="addons.html">插件</a>
            
              <ul>
                
                  <li>
                    <a href="animation.html">动画</a>
                  </li>
                
                  <li>
                    <a href="two-way-binding-helpers.html">双向绑定</a>
                  </li>
                
                  <li>
                    <a href="class-name-manipulation.html">类名操作</a>
                  </li>
                
                  <li>
                    <a href="test-utils.html">测试工具集</a>
                  </li>
                
                  <li>
                    <a href="clone-with-props.html">克隆组件</a>
                  </li>
                
                  <li>
                    <a href="update.html">Immutability Helpers</a>
                  </li>
                
                  <li>
                    <a href="pure-render-mixin.html">PureRenderMixin</a>
                  </li>
                
                  <li>
                    <a href="perf.html">性能分析工具</a>
                  </li>
                
              </ul>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>社区资源</h3>
      <ul>
        
          <li>
            <a href="videos.html">视频</a>
            
          </li>
        
          <li>
            <a href="complementary-tools.html">其余工具</a>
            
          </li>
        
          <li>
            <a href="examples.html">范例</a>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>参考</h3>
      <ul>
        
          <li>
            <a href="top-level-api.html">顶层 API</a>
            
          </li>
        
          <li>
            <a href="component-api.html">组件 API</a>
            
          </li>
        
          <li>
            <a href="component-specs.html" class="active">组件的详细说明和生命周期（Component Specs and Lifecycle）</a>
            
          </li>
        
          <li>
            <a href="tags-and-attributes.html">标签和属性支持</a>
            
          </li>
        
          <li>
            <a href="events.html">事件系统</a>
            
          </li>
        
          <li>
            <a href="dom-differences.html">与 DOM 的差异</a>
            
          </li>
        
          <li>
            <a href="special-non-dom-attributes.html">特殊的非 DOM 属性</a>
            
          </li>
        
          <li>
            <a href="reconciliation.html">Reconciliation</a>
            
          </li>
        
          <li>
            <a href="glossary.html">React （虚拟）DOM 术语</a>
            
          </li>
        
      </ul>
    </div>
  
    <div class="nav-docs-section">
      <h3>Flux</h3>
      <ul>
        
          <li>
            <a href="flux-overview.html">Flux概述</a>
            
          </li>
        
          <li>
            <a href="flux-todo-list.html">Flux的TodoMVC教程</a>
            
          </li>
        
      </ul>
    </div>
  

  <!-- Tips Nav -->
  
    <div class="nav-docs-section">
      <h3>Tips</h3>
      <ul>
        
          <li>
            <a href="introduction.html">内容简介</a>
          </li>
        
          <li>
            <a href="inline-styles.html">内联样式</a>
          </li>
        
          <li>
            <a href="if-else-in-JSX.html">JSX 中的 If-Else</a>
          </li>
        
          <li>
            <a href="self-closing-tag.html">自闭合标签</a>
          </li>
        
          <li>
            <a href="maximum-number-of-jsx-root-nodes.html">JSX 根节点的最大数量</a>
          </li>
        
          <li>
            <a href="style-props-value-px.html">在样式props中快速制定像素值</a>
          </li>
        
          <li>
            <a href="children-props-type.html">子props的类型</a>
          </li>
        
          <li>
            <a href="controlled-input-null-value.html">值为 null 的 Controlled Input</a>
          </li>
        
          <li>
            <a href="componentWillReceiveProps-not-triggered-after-mounting.html">Mounting 后 componentWillReceiveProps 未被触发</a>
          </li>
        
          <li>
            <a href="props-in-getInitialState-as-anti-pattern.html">getInitialState 里的 Props 是一个反模式</a>
          </li>
        
          <li>
            <a href="dom-event-listeners.html">组件的 DOM 事件监听</a>
          </li>
        
          <li>
            <a href="initial-ajax.html">通过 AJAX 加载初始数据</a>
          </li>
        
          <li>
            <a href="false-in-jsx.html">JSX 的 false 处理</a>
          </li>
        
          <li>
            <a href="communicate-between-components.html">组件间的通信</a>
          </li>
        
          <li>
            <a href="expose-component-functions.html">Expose Component Functions</a>
          </li>
        
          <li>
            <a href="references-to-components.html">组件的引用</a>
          </li>
        
          <li>
            <a href="children-undefined.html">this.props.children undefined</a>
          </li>
        
          <li>
            <a href="use-react-with-other-libraries.html">与其他类库并行使用React</a>
          </li>
        
          <li>
            <a href="dangerously-set-inner-html.html">Dangerously Set innerHTML</a>
          </li>
        
      </ul>
    </div>
  
</div>


  <div class="inner-content">
    <h1>
      组件的详细说明和生命周期（Component Specs and Lifecycle）
      <a class="edit-page-link" href="https://github.com/facebook/react/tree/master/docs/docs/ref-03-component-specs.md" target="_blank">Edit on GitHub</a>
    </h1>
    <div class="subHeader"></div>

    <h2><a class="anchor" name="component-specifications"></a>组件的详细说明（Component Specifications） <a class="hash-link" href="component-specs.html#component-specifications">#</a></h2>
<p>当通过调用 <code>React.createClass()</code> 来创建组件的时候，你应该提供一个包含 <code>render</code> 方法的对象，并且也可以包含其它的在这里描述的生命周期方法。</p>
<h3><a class="anchor" name="render"></a>render <a class="hash-link" href="component-specs.html#render">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">ReactComponent</span> <span class="nx">render</span><span class="p">()</span>
</code></pre></div>
<p><code>render()</code> 方法是必须的。</p>

<p>当调用的时候，会检测 <code>this.props</code> 和 <code>this.state</code>，返回一个单子级组件。该子级组件可以是虚拟的本地 DOM 组件（比如 <code>&lt;div /&gt;</code> 或者 <code>React.DOM.div()</code>），也可以是自定义的复合组件。</p>

<p>你也可以返回 <code>null</code> 或者 <code>false</code> 来表明不需要渲染任何东西。实际上，React 渲染一个 <code>&lt;noscript&gt;</code> 标签来处理当前的差异检查逻辑。当返回 <code>null</code> 或者 <code>false</code> 的时候，<code>this.getDOMNode()</code> 将返回 <code>null</code>。</p>

<p><code>render()</code> 函数应该是<em>纯粹的</em>，也就是说该函数不修改组件 state，每次调用都返回相同的结果，不读写 DOM 信息，也不和浏览器交互（例如通过使用 <code>setTimeout</code>）。如果需要和浏览器交互，在 <code>componentDidMount()</code> 中或者其它生命周期方法中做这件事。保持 <code>render()</code> 纯粹，可以使服务器端渲染更加切实可行，也使组件更容易被理解。</p>
<h3><a class="anchor" name="getinitialstate"></a>getInitialState <a class="hash-link" href="component-specs.html#getinitialstate">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">object</span> <span class="nx">getInitialState</span><span class="p">()</span>
</code></pre></div>
<p>在组件挂载之前调用一次。返回值将会作为 <code>this.state</code> 的初始值。</p>
<h3><a class="anchor" name="getdefaultprops"></a>getDefaultProps <a class="hash-link" href="component-specs.html#getdefaultprops">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">object</span> <span class="nx">getDefaultProps</span><span class="p">()</span>
</code></pre></div>
<p>在组件类创建的时候调用一次，然后返回值被缓存下来。如果父组件没有指定 props 中的某个键，则此处返回的对象中的相应属性将会合并到 <code>this.props</code> （使用 <code>in</code> 检测属性）。</p>

<p>该方法在任何实例创建之前调用，因此不能依赖于 <code>this.props</code>。另外，<code>getDefaultProps()</code> 返回的任何复杂对象将会在实例间共享，而不是每个实例拥有一份拷贝。</p>
<h3><a class="anchor" name="proptypes"></a>propTypes <a class="hash-link" href="component-specs.html#proptypes">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">object</span> <span class="nx">propTypes</span>
</code></pre></div>
<p><code>propTypes</code> 对象允许验证传入到组件的 props。更多关于 <code>propTypes</code> 的信息，参考<a href="reusable-components.html">可重用的组件</a>。</p>
<h3><a class="anchor" name="mixins"></a>mixins <a class="hash-link" href="component-specs.html#mixins">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">array</span> <span class="nx">mixins</span>
</code></pre></div>
<p><code>mixin</code> 数组允许使用混合来在多个组件之间共享行为。更多关于混合的信息，参考<a href="reusable-components.html">可重用的组件</a>。</p>
<h3><a class="anchor" name="statics"></a>statics <a class="hash-link" href="component-specs.html#statics">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">object</span> <span class="nx">statics</span>
</code></pre></div>
<p><code>statics</code> 对象允许你定义静态的方法，这些静态的方法可以在组件类上调用。例如：</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kd">var</span> <span class="nx">MyComponent</span> <span class="o">=</span> <span class="nx">React</span><span class="p">.</span><span class="nx">createClass</span><span class="p">({</span>
  <span class="nx">statics</span><span class="o">:</span> <span class="p">{</span>
    <span class="nx">customMethod</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">foo</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="nx">foo</span> <span class="o">===</span> <span class="s1">'bar'</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">},</span>
  <span class="nx">render</span><span class="o">:</span> <span class="kd">function</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">});</span>

<span class="nx">MyComponent</span><span class="p">.</span><span class="nx">customMethod</span><span class="p">(</span><span class="s1">'bar'</span><span class="p">);</span>  <span class="c1">// true</span>
</code></pre></div>
<p>在这个块儿里面定义的方法都是静态的，意味着你可以在任何组件实例创建之前调用它们，这些方法不能获取组件的 props 和 state。如果你想在静态方法中检查 props 的值，在调用处把 props 作为参数传入到静态方法。</p>
<h3><a class="anchor" name="displayname"></a>displayName <a class="hash-link" href="component-specs.html#displayname">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">string</span> <span class="nx">displayName</span>
</code></pre></div>
<p><code>displayName</code> 字符串用于输出调试信息。JSX 自动设置该值；参考<a href="jsx-in-depth.html#react-composite-components">JSX 深入</a>。</p>
<h2><a class="anchor" name=""></a>生命周期方法 <a class="hash-link" href="component-specs.html#">#</a></h2>
<p>许多方法在组件生命周期中某个确定的时间点执行。</p>
<h3><a class="anchor" name="-componentwillmount"></a>挂载： componentWillMount <a class="hash-link" href="component-specs.html#-componentwillmount">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">componentWillMount</span><span class="p">()</span>
</code></pre></div>
<p>服务器端和客户端都只调用一次，在初始化渲染执行之前立刻调用。如果在这个方法内调用 <code>setState</code>，<code>render()</code> 将会感知到更新后的 state，将会执行仅一次，尽管 state 改变了。</p>
<h3><a class="anchor" name="-componentdidmount"></a>挂载： componentDidMount <a class="hash-link" href="component-specs.html#-componentdidmount">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">componentDidMount</span><span class="p">()</span>
</code></pre></div>
<p>在初始化渲染执行之后立刻调用一次，仅客户端有效（服务器端不会调用）。在生命周期中的这个时间点，组件拥有一个 DOM 展现，你可以通过 <code>this.getDOMNode()</code> 来获取相应 DOM 节点。</p>

<p>如果想和其它 JavaScript 框架集成，使用 <code>setTimeout</code> 或者 <code>setInterval</code> 来设置定时器，或者发送 AJAX 请求，可以在该方法中执行这些操作。</p>

<blockquote>
<p>注意：</p>

<p>为了兼容 v0.9，DOM 节点作为最后一个参数传入。你依然可以通过 <code>this.getDOMNode()</code> 获取 DOM 节点。</p>
</blockquote>
<h3><a class="anchor" name="-componentwillreceiveprops"></a>更新： componentWillReceiveProps <a class="hash-link" href="component-specs.html#-componentwillreceiveprops">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">componentWillReceiveProps</span><span class="p">(</span><span class="nx">object</span> <span class="nx">nextProps</span><span class="p">)</span>
</code></pre></div>
<p>在组件接收到新的 props 的时候调用。在初始化渲染的时候，该方法不会调用。</p>

<p>用此函数可以作为 react 在 prop 传入之后， <code>render()</code> 渲染之前更新 state 的机会。老的 props 可以通过 <code>this.props</code> 获取到。在该函数中调用 <code>this.setState()</code> 将不会引起第二次渲染。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">componentWillReceiveProps</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="p">.</span><span class="nx">setState</span><span class="p">({</span>
    <span class="nx">likesIncreasing</span><span class="o">:</span> <span class="nx">nextProps</span><span class="p">.</span><span class="nx">likeCount</span> <span class="o">&gt;</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">likeCount</span>
  <span class="p">});</span>
<span class="p">}</span>
</code></pre></div>
<blockquote>
<p>注意：</p>

<p>对于 state，没有相似的方法： <code>componentWillReceiveState</code>。将要传进来的 prop 可能会引起 state 改变，反之则不然。如果需要在 state 改变的时候执行一些操作，请使用 <code>componentWillUpdate</code>。</p>
</blockquote>
<h3><a class="anchor" name="-shouldcomponentupdate"></a>更新： shouldComponentUpdate <a class="hash-link" href="component-specs.html#-shouldcomponentupdate">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="kr">boolean</span> <span class="nx">shouldComponentUpdate</span><span class="p">(</span><span class="nx">object</span> <span class="nx">nextProps</span><span class="p">,</span> <span class="nx">object</span> <span class="nx">nextState</span><span class="p">)</span>
</code></pre></div>
<p>在接收到新的 props 或者 state，将要渲染之前调用。该方法在初始化渲染的时候不会调用，在使用 <code>forceUpdate</code> 方法的时候也不会。</p>

<p>如果确定新的 props 和 state 不会导致组件更新，则此处应该 <code>返回 false</code>。</p>
<div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">shouldComponentUpdate</span><span class="o">:</span> <span class="kd">function</span><span class="p">(</span><span class="nx">nextProps</span><span class="p">,</span> <span class="nx">nextState</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="nx">nextProps</span><span class="p">.</span><span class="nx">id</span> <span class="o">!==</span> <span class="k">this</span><span class="p">.</span><span class="nx">props</span><span class="p">.</span><span class="nx">id</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div>
<p>如果 <code>shouldComponentUpdate</code> 返回 false，则 <code>render()</code> 将不会执行，直到下一次 state 改变。（另外，<code>componentWillUpdate</code> 和 <code>componentDidUpdate</code> 也不会被调用。）</p>

<p>默认情况下，<code>shouldComponentUpdate</code> 总会返回 true，在 <code>state</code> 改变的时候避免细微的 bug，但是如果总是小心地把 <code>state</code> 当做不可变的，在 <code>render()</code> 中只从 <code>props</code> 和 <code>state</code> 读取值，此时你可以覆盖 <code>shouldComponentUpdate</code> 方法，实现新老 props 和 state 的比对逻辑。</p>

<p>如果性能是个瓶颈，尤其是有几十个甚至上百个组件的时候，使用 <code>shouldComponentUpdate</code> 可以提升应用的性能。</p>
<h3><a class="anchor" name="-componentwillupdate"></a>更新： componentWillUpdate <a class="hash-link" href="component-specs.html#-componentwillupdate">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">componentWillUpdate</span><span class="p">(</span><span class="nx">object</span> <span class="nx">nextProps</span><span class="p">,</span> <span class="nx">object</span> <span class="nx">nextState</span><span class="p">)</span>
</code></pre></div>
<p>在接收到新的 props 或者 state 之前立刻调用。在初始化渲染的时候该方法不会被调用。</p>

<p>使用该方法做一些更新之前的准备工作。</p>

<blockquote>
<p>注意：</p>

<p>你<em>不能</em>在刚方法中使用 <code>this.setState()</code>。如果需要更新 state 来响应某个 prop 的改变，请使用 <code>componentWillReceiveProps</code>。</p>
</blockquote>
<h3><a class="anchor" name="-componentdidupdate"></a>更新： componentDidUpdate <a class="hash-link" href="component-specs.html#-componentdidupdate">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">componentDidUpdate</span><span class="p">(</span><span class="nx">object</span> <span class="nx">prevProps</span><span class="p">,</span> <span class="nx">object</span> <span class="nx">prevState</span><span class="p">)</span>
</code></pre></div>
<p>在组件的更新已经同步到 DOM 中之后立刻被调用。该方法不会在初始化渲染的时候调用。</p>

<p>使用该方法可以在组件更新之后操作 DOM 元素。</p>

<blockquote>
<p>注意：</p>

<p>为了兼容 v0.9，DOM 节点会作为最后一个参数传入。如果使用这个方法，你仍然可以使用 <code>this.getDOMNode()</code> 来访问 DOM 节点。</p>
</blockquote>
<h3><a class="anchor" name="-componentwillunmount"></a>移除： componentWillUnmount <a class="hash-link" href="component-specs.html#-componentwillunmount">#</a></h3><div class="highlight"><pre><code class="language-javascript" data-lang="javascript"><span class="nx">componentWillUnmount</span><span class="p">()</span>
</code></pre></div>
<p>在组件从 DOM 中移除的时候立刻被调用。</p>

<p>在该方法中执行任何必要的清理，比如无效的定时器，或者清除在 <code>componentDidMount</code> 中创建的 DOM 元素。</p>


    <div class="docs-prevnext">
      
        <a class="docs-prev" href="component-api.html">← 上一条</a>
      
      
        <a class="docs-next" href="tags-and-attributes.html">下一条 →</a>
      
    </div>
  </div>
</section>


    <footer class="wrap">
      <div class="left">
        A Facebook &amp; Instagram collaboration.<br>
        <a href="acknowledgements.html">Acknowledgements</a>
      </div>
      <div class="right">
        © 2013–2015 Facebook Inc.<br>
        Documentation licensed under <a href="http://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a>.
      </div>
    </footer>
  </div>
  <div id="fb-root"></div>



</body></html>